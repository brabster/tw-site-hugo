<!doctype html><html lang=en data-theme=dark><head><title>Paul Brabban | Performance with Spring Boot and Gatling (Part 1)</title><meta charset=utf-8><meta name=generator content="Hugo 0.69.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="Software and Data Consulting Services"><link rel=stylesheet href=/css/style.min.e332b070abdcc736bb1e21feb22a6be1524dcddef4e12f6d5d569adfb8dcb51a.css integrity="sha256-4zKwcKvcxza7HiH+sipr4VJNzd704S9tXVaa37jctRo=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=/posts/2019-01-07-spring-boot-performance-part-1/><script type=text/javascript src=/js/anatole-header.min.e782db136ec18d105a4552702eac49f4620d6867da3fbf808bd53e806c96be6e.js integrity="sha256-54LbE27BjRBaRVJwLqxJ9GINaGfaP7+Ai9U+gGyWvm4=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="47"><meta name=twitter:title content="Performance with Spring Boot and Gatling (Part 1)"><meta name=twitter:description content="Exploring a surprising performance problem in a simple Spring Boot app with the Gatling load testing framework."></head><body><div class="sidebar animated fadeInDown"><div class=logo-title><div class=title><img src=/about/profile.jpeg alt="profile picture"><h3><a href=/>Tempered Works</a></h3><div class=description><p>Software and Data Consulting Services</p></div></div></div><ul class=social-links><li><a href=https://linkedin.com/in/paulbrabban rel=me aria-label=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li><a href=https://github.com/brabster rel=me aria-label=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li><a href=https://twitter.com/brabster rel=me aria-label=instagram><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li><a href=mailto:paul@tempered.works rel=me aria-label=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul><div class=footer><div class=by_farbox>&copy; Paul Brabban 2020</div></div></div><div class=main><div class="page-top animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a><ul class=nav id=navMenu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/about/>About</a></li><li class=theme-switch-item><a class=theme-switch title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></li></ul></div><div class=autopagerize_page_element><div class=content><div class="post animated fadeInDown"><div class=post-content><div class=post-title><h3>Performance with Spring Boot and Gatling (Part 1)</h3></div><p>Just after the rest of the team had left for their Christmas holidays, my colleague and I discovered a weird performance problem with a Spring Boot application we&rsquo;d just started writing.
This is a the story of discovering the problem and the detective work that led us to the culprit hiding in plain sight.
We&rsquo;re going to recreate the app and the performance tests, but first I&rsquo;ll tell you how we got here.</p><h2 id=prologue>Prologue</h2><p>Twenty requests per second.
Any more than that and response times would climb.
Eventually, the load balancer&rsquo;s readiness checks would timeout and it&rsquo;d refuse to send traffic to the app, taking the service offline.</p><p>Here&rsquo;s what our little prototype system looked like:</p><p><img src=orig-arch-diag.jpg alt="Diagram showing the components parts of the prototype when we discovered the performance problem"></p><p>We&rsquo;re building an API, rather than a website.
Clients authenticate by passing a username and password in the request.
Each request is a query, and the app talks to a graph database to calculate an answer, returning it as a JSON document.
It&rsquo;s running in a Kubernetes cluster on AWS, behind an Elastic Load Balancer.</p><p>How can it be struggling to serve more than twenty requests per second?
I&rsquo;ve not used this graph database before, can it really be that slow? Nor have I used Kubernetes or Spring Boot, are they responsible? You wouldn&rsquo;t think there&rsquo;d be enough of our code yet to perform so poorly, but our own code is always the go-to suspect.</p><h2 id=too-many-suspects>Too Many Suspects</h2><p>There&rsquo;s too many potential culprits here, so let&rsquo;s eliminate some. Can I reproduce the problem here on my machine? Yes - and I get a clue. As the test runs, I can hear the fan spinning up. Checking back on AWS for server metrics, the CPU utilisation was shooting up to 100% during the test. That removes Kubernetes, the load balancer, the network and disks from the investigation, at least for now. Memory could still be a problem, as Java&rsquo;s garbage collection chews up compute time when there&rsquo;s not enough memory.</p><p>Now we eliminate the database. We&rsquo;d written a resource to return version information, which is just returning a document from memory. Running the performance test on that endpoint revealed the same terrible performance! Something to do with the Spring framework, or the Tomcat application server then - where can we go from here?</p><p>We <em>could</em> pull out profiler tooling to look inside the running app and see what&rsquo;s going on. It&rsquo;s been a while since I used that tooling on the JVM, and it&rsquo;ll produce a lot information to interpret, so I&rsquo;ll leave that as a backup plan. For now, we&rsquo;ve got an easy option that will rule out the Spring Boot framework and Tomcat application server. A &ldquo;getting started&rdquo; Spring Boot app won&rsquo;t take long to set up. We can eliminate JSON processing, configuration problems and coding errors as potential candidates, and get a benchmark for how performant the simplest Spring Boot app is with our hardware and test setup.</p><p>This is where we write some code.</p><h2 id=the-getting-started-app>The &ldquo;Getting Started&rdquo; App</h2><p>You can find and clone the project we&rsquo;re talking about in this post on Github at <a href=https://github.com/brabster/performance-with-spring-boot/tree/1.0>https://github.com/brabster/performance-with-spring-boot/tree/1.0</a>. You&rsquo;ll need a JDK and Maven installed to compile and run the application.</p><p>I based the &ldquo;getting started&rdquo; app closely on <a href=https://spring.io/guides/gs/spring-boot/>Spring Boot&rsquo;s documentation</a>. It&rsquo;s got one endpoint at <code>/</code> and returns a JSON document <code>{"greeting": "Greetings from Spring Boot!"}</code> like <a href=https://github.com/brabster/performance-with-spring-boot/blob/1.0/src/main/java/hello/HelloController.java>this</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> hello<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> org.springframework.web.bind.annotation.RestController<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.springframework.web.bind.annotation.RequestMapping<span style=color:#f92672>;</span>

<span style=color:#a6e22e>@RestController</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloController</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Greeting</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getGreeting</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Greetings from Spring Boot!&#34;</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@RequestMapping</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>public</span> Greeting <span style=color:#a6e22e>index</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Greeting<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>
</code></pre></div><p>We&rsquo;ll use Spring Security to authenticate API clients, so we need to add the dependencies and set a default username and password. The dependencies we need to add to our Maven <a href=https://github.com/brabster/performance-with-spring-boot/blob/1.0/pom.xml>pom.xml</a> file are:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;dependency&gt;</span>
    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.security<span style=color:#f92672>&lt;/groupId&gt;</span>
    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-security-web<span style=color:#f92672>&lt;/artifactId&gt;</span>
    <span style=color:#f92672>&lt;version&gt;</span>5.1.2.RELEASE<span style=color:#f92672>&lt;/version&gt;</span>
<span style=color:#f92672>&lt;/dependency&gt;</span>
<span style=color:#f92672>&lt;dependency&gt;</span>
    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.security<span style=color:#f92672>&lt;/groupId&gt;</span>
    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-security-config<span style=color:#f92672>&lt;/artifactId&gt;</span>
    <span style=color:#f92672>&lt;version&gt;</span>5.1.2.RELEASE<span style=color:#f92672>&lt;/version&gt;</span>
<span style=color:#f92672>&lt;/dependency&gt;</span>
</code></pre></div><p>To set a default username and password, we add a <a href=https://github.com/brabster/performance-with-spring-boot/blob/1.0/src/main/resources/application.properties>properties file</a> containing two properties that override Spring Security&rsquo;s defaults:</p><pre><code>spring.security.user.name=user
spring.security.user.password=24gh39ugh0
</code></pre><p>Start the app with <code>mvn spring-boot:run</code> and you should see something like this:</p><p><img src=start-app.gif alt="Asciinema recording of the app starting"></p><h2 id=performance-testing-with-gatling>Performance Testing with Gatling</h2><p><a href=https://gatling.io/>Gatling</a> is the tooling that gave us those original requests per second figures, so let&rsquo;s reproduce the setup to do our performance tests here. Gatling tests are written in Scala and can coexist with the Java code, but we need a little support in our project to run tests and get editor support for Scala.</p><p>To compile Scala code and enable Scala support (at least in <a href=https://www.jetbrains.com/idea/>IntelliJ IDEA</a>) I used the rather neat <a href=https://davidb.github.io/scala-maven-plugin/index.html>scala-maven-plugin</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;plugin&gt;</span>
    <span style=color:#f92672>&lt;groupId&gt;</span>net.alchim31.maven<span style=color:#f92672>&lt;/groupId&gt;</span>
    <span style=color:#f92672>&lt;artifactId&gt;</span>scala-maven-plugin<span style=color:#f92672>&lt;/artifactId&gt;</span>
    <span style=color:#f92672>&lt;version&gt;</span>3.4.4<span style=color:#f92672>&lt;/version&gt;</span>
    <span style=color:#f92672>&lt;executions&gt;</span>
        <span style=color:#f92672>&lt;execution&gt;</span>
            <span style=color:#f92672>&lt;id&gt;</span>scala-test-compile<span style=color:#f92672>&lt;/id&gt;</span>
            <span style=color:#f92672>&lt;phase&gt;</span>process-test-resources<span style=color:#f92672>&lt;/phase&gt;</span>
            <span style=color:#f92672>&lt;goals&gt;</span>
                <span style=color:#f92672>&lt;goal&gt;</span>testCompile<span style=color:#f92672>&lt;/goal&gt;</span>
            <span style=color:#f92672>&lt;/goals&gt;</span>
        <span style=color:#f92672>&lt;/execution&gt;</span>
    <span style=color:#f92672>&lt;/executions&gt;</span>
<span style=color:#f92672>&lt;/plugin&gt;</span>
</code></pre></div><p>To run Gatling from Maven and view its output, we need a dependency and a plugin:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;dependency&gt;</span>
    <span style=color:#f92672>&lt;groupId&gt;</span>io.gatling.highcharts<span style=color:#f92672>&lt;/groupId&gt;</span>
    <span style=color:#f92672>&lt;artifactId&gt;</span>gatling-charts-highcharts<span style=color:#f92672>&lt;/artifactId&gt;</span>
    <span style=color:#f92672>&lt;scope&gt;</span>test<span style=color:#f92672>&lt;/scope&gt;</span>
    <span style=color:#f92672>&lt;version&gt;</span>3.0.2<span style=color:#f92672>&lt;/version&gt;</span>
<span style=color:#f92672>&lt;/dependency&gt;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;plugin&gt;</span>
    <span style=color:#f92672>&lt;groupId&gt;</span>io.gatling<span style=color:#f92672>&lt;/groupId&gt;</span>
    <span style=color:#f92672>&lt;artifactId&gt;</span>gatling-maven-plugin<span style=color:#f92672>&lt;/artifactId&gt;</span>
    <span style=color:#f92672>&lt;version&gt;</span>3.0.1<span style=color:#f92672>&lt;/version&gt;</span>
<span style=color:#f92672>&lt;/plugin&gt;</span>
</code></pre></div><p>Now we can write a Gatling test. This is our scenario, describing the client behaviour we want to test.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>setUp<span style=color:#f92672>(</span>myScenario<span style=color:#f92672>.</span>inject<span style=color:#f92672>(</span>
    incrementUsersPerSec<span style=color:#f92672>(</span><span style=color:#ae81ff>20</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>times<span style=color:#f92672>(</span><span style=color:#ae81ff>5</span><span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>eachLevelLasting<span style=color:#f92672>(</span><span style=color:#ae81ff>5</span> seconds<span style=color:#f92672>)</span>
      <span style=color:#f92672>.</span>startingFrom<span style=color:#f92672>(</span><span style=color:#ae81ff>20</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>)).</span>protocols<span style=color:#f92672>(</span>httpProtocol<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span>assertions<span style=color:#f92672>(</span>global<span style=color:#f92672>.</span>successfulRequests<span style=color:#f92672>.</span>percent<span style=color:#f92672>.</span>is<span style=color:#f92672>(</span><span style=color:#ae81ff>100</span><span style=color:#f92672>))</span>
</code></pre></div><p>We&rsquo;re starting with 20 users per second making a request to the <code>/</code> resource, holding at that concurrency for five seconds. They only make one request. Then we increase the number of users per second by twenty, five times, holding for five seconds each time. Every request must return an HTTP 200 status code to pass the test. Simple! You&rsquo;ll find the rest of the test in <a href=https://github.com/brabster/performance-with-spring-boot/blob/1.0/src/test/scala/hello/LoadTest.scala>LoadTest.scala</a>.</p><p>Make sure the app is running and then run the test with <code>mvn gatling:test</code>.</p><p><img src=perf-test-1.gif alt="Asciinema recording of the performance test running"></p><p>When the tests run you see a progress bar being refreshed every few seconds. The <code>###</code> part represents the proportion of requests that have been made and completed. The section with dashes <code>---</code> is requests made but not yet completed. The numbers are just below the progress bar, <code>active</code> telling us how many requests have been made but not yet completed. There&rsquo;s a lot of those, over a thousand towards the end of the test, and this computer isn&rsquo;t exactly underpowered. There&rsquo;s our performance problem! Towards the end of the test, requests are taking over 26 seconds to complete.</p><p>If you cloned the project, you can try changing the scenario in <a href=https://github.com/brabster/performance-with-spring-boot/blob/1.0/src/test/scala/hello/LoadTest.scala>LoadTest.scala</a> to explore the problem. Running something like <code>top</code> will show you your live CPU utilisation. I can see the app using almost a full 4 cores while the test is running. To serve a short text string from memory to less than 100 users per second!</p><h2 id=gatlings-reports>Gatling&rsquo;s Reports</h2><p>Gatling saves a report of metrics and charts for each test. There&rsquo;s a couple that I think give us interesting insight into what just happened that we might not have seen as the test was running.</p><p><img src=gatling-slow-response-time-distribution.png alt="Bar chart showing 15 requests responded in around 200 milliseconds, with other requests uniformly distributed up to almost 30 seconds"></p><p>The &ldquo;Response Time Distribution&rdquo; report tells us that the fastest few requests are served in around 200ms. So it takes at least 200ms to serve a request! Then there&rsquo;s an roughly uniform distribution of request times up to 30 seconds. The test only ran for around 70 seconds in total.</p><p>Next, the &ldquo;Number of requests per second&rdquo; chart shows more clearly that the app isn&rsquo;t keeping up, even with these low request rates. The number of active users (those that have made a request and not yet had a response) climbs until Gatling stops sending new requests.</p><p><img src=gatling-slow-request-response-rate.png alt="Line chart showing the number of new requests per second and the number of active requests over time."></p><p>You can see the app is not quite able to keep up at 40 requests per second. as we ramp to 60 the line swings upwards as it really starts to fall behind. 45 seconds or so into the test the number of requests per second drops from 100 to zero, and the number of active requests, just over 1000 by this point, stops climbing and starts to fall as the app starts to clear its backlog.</p><p>Gatling&rsquo;s reports show you plenty of other interesting charts and figures. Find them in your <code>target</code> directory after running a test.</p><h2 id=next-time>Next Time</h2><p>That&rsquo;s the context, the tools and a simple codebase to get us started. In <a href=/posts/spring-boot-performance-part-2>Part 2</a>, we see how a performance problem shows itself and figure out how to resolve it.</p></div><div class=post-footer><div class=info><span class=separator><a class=tag href=/tags/web-development/>web-development</a><a class=tag href=/tags/performance-testing/>performance-testing</a><a class=tag href=/tags/spring-boot/>spring-boot</a><a class=tag href=/tags/spring-security/>spring-security</a><a class=tag href=/tags/gatling/>gatling</a><a class=tag href=/tags/java/>java</a><a class=tag href=/tags/scala/>scala</a></span></div></div></div></div></div></div><script type=text/javascript src=/js/jquery.min.86b1e8f819ee2d9099a783e50b49dff24282545fc40773861f9126b921532e4c.js integrity="sha256-hrHo+BnuLZCZp4PlC0nf8kKCVF/EB3OGH5EmuSFTLkw=" crossorigin=anonymous></script><script type=text/javascript src=/js/bundle.min.0f9c74cb78f13d1f15f33daff4037c70354f98acfbb97a6f61708966675c3cae.js integrity="sha256-D5x0y3jxPR8V8z2v9AN8cDVPmKz7uXpvYXCJZmdcPK4=" crossorigin=anonymous></script><script type=text/javascript src=/js/medium-zoom.min.92f21c856129f84aeb719459b3e6ac621a3032fd7b180a18c04e1d12083f8aba.js integrity="sha256-kvIchWEp+ErrcZRZs+asYhowMv17GAoYwE4dEgg/iro=" crossorigin=anonymous></script></body></html>